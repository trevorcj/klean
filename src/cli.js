const fs = require('node:fs/promises')
const path = require('node:path')
const { spawn } = require('node:child_process')
const inquirer = require('inquirer')

const JS_YELLOW = '\x1b[33mJavaScript\x1b[0m'
const TS_BLUE = '\x1b[34mTypeScript\x1b[0m'

const KLEAN_LOGO = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128" role="img" aria-label="Klean logo">
  <rect width="128" height="128" rx="24" fill="#111827"/>
  <path d="M34 30v68h16V70l30 28h22L66 64l34-34H78L50 58V30z" fill="#22d3ee"/>
</svg>
`

function runCommand(command, args, options = {}) {
  return new Promise((resolve, reject) => {
    const child = spawn(command, args, {
      stdio: 'inherit',
      shell: process.platform === 'win32',
      ...options
    })

    child.on('error', reject)
    child.on('close', (code) => {
      if (code === 0) {
        resolve()
        return
      }

      reject(new Error(`Command failed: ${command} ${args.join(' ')}`))
    })
  })
}

async function pathExists(targetPath) {
  try {
    await fs.access(targetPath)
    return true
  } catch {
    return false
  }
}

function getTemplate(language) {
  return language === 'TypeScript' ? 'react-ts' : 'react'
}

function getExtension(language) {
  return language === 'TypeScript' ? 'tsx' : 'jsx'
}

async function getProjectConfig() {
  const providedProjectName = process.argv[2]

  const questions = []

  if (!providedProjectName) {
    questions.push({
      type: 'input',
      name: 'projectName',
      message: 'Project name:',
      validate(input) {
        if (!input.trim()) {
          return 'Project name is required.'
        }

        return true
      }
    })
  }

  questions.push(
    {
      type: 'list',
      name: 'language',
      message: 'Language:',
      choices: [
        { name: JS_YELLOW, value: 'JavaScript', short: 'JavaScript' },
        { name: TS_BLUE, value: 'TypeScript', short: 'TypeScript' }
      ],
      default: 'JavaScript'
    },
    {
      type: 'confirm',
      name: 'tailwind',
      message: 'Install Tailwind CSS?',
      default: true
    },
    {
      type: 'list',
      name: 'structure',
      message: 'Which folder structure do you prefer?',
      choices: [
        { name: 'Plain (minimal setup)', value: 'plain' },
        { name: 'Feature-based (recommended for larger projects)', value: 'feature' }
      ],
      default: 'plain'
    }
  )

  const answers = await inquirer.prompt(questions)

  return {
    projectName: providedProjectName || answers.projectName,
    language: answers.language,
    tailwind: answers.tailwind,
    structure: answers.structure
  }
}

function appTemplate() {
  return `function App() {
  return <div>Hello world</div>
}

export default App
`
}

function mainTemplate(extension) {
  const isTs = extension === 'tsx'

  if (isTs) {
    return `import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
)
`
  }

  return `import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>
)
`
}

function projectReadmeTemplate({ projectName, language, tailwind, structure }) {
  const setup = `## Development\n\n\`\`\`bash\nnpm install\nnpm run dev\n\`\`\``
  const build = '## Build\n\n```bash\nnpm run build\n```'
  const stack = [
    '- React',
    '- Vite (scaffolding + dev server)',
    `- Language: ${language}`,
    `- Tailwind CSS: ${tailwind ? 'Enabled' : 'Not enabled'}`,
    `- Structure: ${structure === 'plain' ? 'Plain' : 'Feature-based'}`
  ].join('\n')

  return `# ${projectName}

Generated by **Klean** â€” a minimal, opinionated React initializer powered by Vite under the hood.

## Stack
${stack}

${setup}

${build}
`
}

async function scaffoldProject(projectName, template) {
  await runCommand('npm', ['create', 'vite@latest', projectName, '--', '--template', template, '--no-interactive'])
}

async function installDependencies(projectDir) {
  await runCommand('npm', ['install'], { cwd: projectDir })
}

async function cleanViteDefaults(projectDir, extension) {
  const srcDir = path.join(projectDir, 'src')
  const publicDir = path.join(projectDir, 'public')

  await fs.rm(path.join(srcDir, 'assets', 'react.svg'), { force: true })
  await fs.rm(path.join(srcDir, 'App.css'), { force: true })
  await fs.rm(path.join(publicDir, 'vite.svg'), { force: true })

  await fs.writeFile(path.join(srcDir, `App.${extension}`), appTemplate(), 'utf8')
  await fs.writeFile(path.join(srcDir, `main.${extension}`), mainTemplate(extension), 'utf8')
}

async function ensureFolderStructure(projectDir, structure, language) {
  const srcDir = path.join(projectDir, 'src')

  if (structure === 'plain') {
    await fs.mkdir(path.join(srcDir, 'components'), { recursive: true })
    return
  }

  const folders = ['assets', 'features', 'ui', 'services', 'utils', 'hooks']
  if (language === 'TypeScript') {
    folders.push('types')
  }

  await Promise.all(folders.map((folder) => fs.mkdir(path.join(srcDir, folder), { recursive: true })))
}

async function setupTailwind(projectDir) {
  await runCommand('npm', ['install', '-D', 'tailwindcss', '@tailwindcss/vite'], { cwd: projectDir })

  const viteConfigTs = path.join(projectDir, 'vite.config.ts')
  const viteConfigJs = path.join(projectDir, 'vite.config.js')
  const targetPath = (await pathExists(viteConfigTs)) ? viteConfigTs : viteConfigJs
  const config = await fs.readFile(targetPath, 'utf8')

  let updated = config
  if (!updated.includes('@tailwindcss/vite')) {
    updated = `import tailwindcss from '@tailwindcss/vite'\n${updated}`
  }

  updated = updated.replace(/plugins:\s*\[react\(\)\]/, 'plugins: [react(), tailwindcss()]')

  await fs.writeFile(targetPath, updated, 'utf8')
}

async function setupStyling(projectDir, withTailwind) {
  const indexCssPath = path.join(projectDir, 'src', 'index.css')
  const content = withTailwind ? '@import "tailwindcss";\n' : ''
  await fs.writeFile(indexCssPath, content, 'utf8')
}

async function updateHtml(projectDir, projectName) {
  const indexHtmlPath = path.join(projectDir, 'index.html')
  const publicLogoPath = path.join(projectDir, 'public', 'klean-logo.svg')

  await fs.writeFile(publicLogoPath, KLEAN_LOGO, 'utf8')

  const html = await fs.readFile(indexHtmlPath, 'utf8')
  const updated = html
    .replace(/href="\/vite\.svg"/g, 'href="/klean-logo.svg"')
    .replace(/<title>.*<\/title>/, `<title>${projectName}</title>`)

  await fs.writeFile(indexHtmlPath, updated, 'utf8')
}

async function writeProjectReadme(projectDir, projectName, language, tailwind, structure) {
  const readmePath = path.join(projectDir, 'README.md')
  const content = projectReadmeTemplate({ projectName, language, tailwind, structure })
  await fs.writeFile(readmePath, content, 'utf8')
}

async function run() {
  console.log('ðŸ§¼ Klean â€” opinionated React project initializer\n')

  const { projectName, language, tailwind, structure } = await getProjectConfig()
  const projectDir = path.resolve(process.cwd(), projectName)

  if (await pathExists(projectDir)) {
    throw new Error(`Directory already exists: ${projectName}`)
  }

  const extension = getExtension(language)
  const template = getTemplate(language)

  await scaffoldProject(projectName, template)

  console.log(`\nðŸ“¦ Scaffolding done. Installing project dependencies for ${projectName}...`)
  await installDependencies(projectDir)

  await cleanViteDefaults(projectDir, extension)
  await ensureFolderStructure(projectDir, structure, language)

  if (tailwind) {
    console.log('ðŸŽ¨ Installing and configuring Tailwind CSS...')
    await setupTailwind(projectDir)
  }

  await setupStyling(projectDir, tailwind)
  await updateHtml(projectDir, projectName)
  await writeProjectReadme(projectDir, projectName, language, tailwind, structure)

  console.log('\nâœ… Project created successfully! Klean architecture applied. Ready to build.')
  console.log(`\nNext steps:\n  cd ${projectName}\n  npm run dev`)
}

module.exports = {
  run
}
